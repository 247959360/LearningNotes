<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="app">
    {{ arr[0].a }}
  </div>
  <script src="../dist/vue.js" type="text/javascript"></script>
  
  <script>
    let vm = new Vue({
      el: '#app',
      data() {
        return { name: 'sgjm', age: { age: 18 }, arr: [1,[1, [1, [2]]], 2] }
      },
      computed() {},
      watch() {},
      beforeCreate() {
        console.log("user")
      },
      created() {
        console.log(this.age, 'this.age')
      },
      beforeMount() {
        console.log(this.el, 'beforeMount')
      },
      mounted() {
        console.log(this.el, 'mounted')
      }
    })
    // 这样操作不方便 当用户可以直接改
    // 如果设置的值是一个对象  还需要在进行劫持
    // vm._data.address = {age: '1'}
    // console.log(vm, 'index.html')
    // console.log(vm.name)
    // vm.study = {
    //   name: 'wm',
    //   age: 22
    // }
    // vm.$set({}, 'name', 'shangguan')
    // console.log(vm)
    // vm._data.b = 5;
    // console.log(vm)
    // function A() {
    // }
    // console.log(new A())
    // with(vm) { // with就相当于改变了当前取值的作用域
    //   console.log(name, "name的值")
    // }
    // 调用render方法  就会进行取值， 取值的化就会走数据劫持的get方法
    // setTimeout(() => {
    //   vm.age = 1000
    //   vm.age = 101
    //   vm.age = 2000
    //   // vm.age = 101
    //   // vm.age = 102
    //   // 属性变了  调用_render 方法 获取新的虚拟dom， 重新更新数据_update
    //   // 手动渲染数据  还有ast语法树 生成jsx语法那块也需要处理
    //   // 这里vm.age 只是改变值  没有改变ast语法树的节点
    //   // vm._update(vm._render()) // 数据变化重新执行渲染watcher
    // }, 1000)
    // setTimeout(() => {
    //   // vm.name = "为名"
    //   vm.name = "上官"
    //   // vm.name = "前端"
    // }, 3000)
    // vm.arr.push(3)
    // console.log(vm)
    // vm.arr[0] = 100
    // vm.age.age = 100
    // vm.name = 100
    // console.log(vm)
    setTimeout(() => {
      vm.arr[0].a = 40
      vm.arr[0].a = 41
      vm.arr[0].a = 42
      vm.arr[0].a = 43
      vm.arr[0].a = 44
      vm.arr[0].a = 45
      // 因为使用了异步更新  用户就无法立即拿到里面的内容了
      
      vm.$nextTick(() => {
        console.log(vm.$el.innerHTML, 'vm.$el.innerHTML')
      })

    }, 2000)
  </script>
</body>

</html>