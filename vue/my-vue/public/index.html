<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="app">
    <span>{{age}}</span>
  </div>
  <script src="../dist/vue.js" type="text/javascript"></script>
  
  <script>
    let vm = new Vue({
      el: '#app',
      data() {
        return { name: 'sgjm', age: 18 }
      },
      computed() {},
      watch() {},
      beforeCreate() {
        console.log("user")
      },
      created() {
        console.log(this.age, 'this.age')
      },
      beforeMount() {
        console.log(this.el, 'beforeMount')
      },
      mounted() {
        console.log(this.el, 'mounted')
      }
    })
    // 这样操作不方便 当用户可以直接改
    // 如果设置的值是一个对象  还需要在进行劫持
    // vm._data.address = {age: '1'}
    // console.log(vm, 'index.html')
    // console.log(vm.name)
    // vm.study = {
    //   name: 'wm',
    //   age: 22
    // }
    // vm.$set({}, 'name', 'shangguan')
    // console.log(vm)
    // vm._data.b = 5;
    // console.log(vm)
    // function A() {
    // }
    // console.log(new A())
    // with(vm) { // with就相当于改变了当前取值的作用域
    //   console.log(name, "name的值")
    // }
    // 调用render方法  就会进行取值， 取值的化就会走数据劫持的get方法
    setTimeout(() => {
      vm.age = 1000
      vm.age = 101
      // vm.age = 101
      // vm.age = 102
      // 属性变了  调用_render 方法 获取新的虚拟dom， 重新更新数据_update
      // 手动渲染数据  还有ast语法树 生成jsx语法那块也需要处理
      // 这里vm.age 只是改变值  没有改变ast语法树的节点
      // vm._update(vm._render()) // 数据变化重新执行渲染watcher
    }, 1000)
    // console.log(vm)
  </script>
</body>

</html>